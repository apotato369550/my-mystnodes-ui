#!/bin/bash

#####################################################################
# MystNodes - Mysterium Network Node Management Tool
#
# A unified bash-based tool for managing and monitoring Mysterium
# Network nodes across multiple instances via TequilAPI
#
# Usage:
#   ./my_myst_nodes                    # Interactive menu mode
#   ./my_myst_nodes status [all|NODE]  # Check node status
#   ./my_myst_nodes add NAME HOST      # Add new node
#   ./my_myst_nodes remove NODE        # Remove node
#   ./my_myst_nodes list               # List all nodes
#   ./my_myst_nodes verbose [on|off]   # Toggle verbose mode
#####################################################################

# ANSI Color Codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Configuration Files
CONFIG_DIR="$HOME/.mystnodes"
NODES_FILE="$CONFIG_DIR/nodes"
CONFIG_FILE="$CONFIG_DIR/config"
ONBOARDED_FILE="$CONFIG_DIR/onboarded"

# Default Configuration
DEFAULT_PORT=4050
DEFAULT_USER="myst"
DEFAULT_PASS="mystberry"
VERBOSE_MODE=false

# Menu State
MENU_SELECTED=0
MENU_SIZE=0

#####################################################################
# Initialization Functions
#####################################################################

init_config() {
    # Create config directory if it doesn't exist
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
    fi

    # Create nodes file if it doesn't exist
    if [ ! -f "$NODES_FILE" ]; then
        touch "$NODES_FILE"
    fi

    # Create config file if it doesn't exist
    if [ ! -f "$CONFIG_FILE" ]; then
        cat > "$CONFIG_FILE" <<EOF
DEFAULT_PORT=$DEFAULT_PORT
DEFAULT_USER=$DEFAULT_USER
DEFAULT_PASS=$DEFAULT_PASS
VERBOSE_MODE=false
EOF
    fi

    # Create onboarded file if it doesn't exist
    if [ ! -f "$ONBOARDED_FILE" ]; then
        touch "$ONBOARDED_FILE"
    fi

    # Create exports directory if it doesn't exist
    local EXPORTS_DIR="$CONFIG_DIR/exports"
    if [ ! -d "$EXPORTS_DIR" ]; then
        mkdir -p "$EXPORTS_DIR"
    fi

    # Load configuration
    load_config
}

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    fi
}

save_config() {
    cat > "$CONFIG_FILE" <<EOF
DEFAULT_PORT=$DEFAULT_PORT
DEFAULT_USER=$DEFAULT_USER
DEFAULT_PASS=$DEFAULT_PASS
VERBOSE_MODE=$VERBOSE_MODE
EOF
}

#####################################################################
# Display Helper Functions
#####################################################################

resolve_host() {
    local host=$1
    # If host is already an IP, return it
    if [[ "$host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "$host"
        return
    fi
    
    # Try to resolve
    local ip=""
    if command -v getent &> /dev/null; then
        ip=$(getent hosts "$host" | awk '{ print $1 }' | head -n 1)
    elif command -v ping &> /dev/null; then
        ip=$(ping -c 1 "$host" 2>/dev/null | head -n 1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | head -n 1)
    fi
    
    if [ -n "$ip" ]; then
        echo "$ip"
    else
        echo "$host"
    fi
}

print_header() {
    clear
    echo -e "${BLUE}${BOLD}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}${BOLD}  MystNodes - Mysterium Network Node Manager${NC}"
    echo -e "${BLUE}${BOLD}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
}

print_section() {
    echo -e "${CYAN}${BOLD}──────────────────────────────────────────────────────────────${NC}"
    echo -e "${CYAN}${BOLD}  $1${NC}"
    echo -e "${CYAN}${BOLD}──────────────────────────────────────────────────────────────${NC}"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

#####################################################################
# Node Management Functions
#####################################################################

get_node_list() {
    if [ ! -f "$NODES_FILE" ]; then
        echo ""
        return
    fi
    cat "$NODES_FILE"
}

node_exists() {
    local name=$1
    grep -q "^${name}|" "$NODES_FILE" 2>/dev/null
}

get_node_info() {
    local name=$1
    grep "^${name}|" "$NODES_FILE" 2>/dev/null
}

add_node() {
    local name=$1
    local host=$2
    local port=${3:-$DEFAULT_PORT}
    local user=${4:-$DEFAULT_USER}
    local pass=${5:-$DEFAULT_PASS}
    local api_key=$6

    # Validate inputs
    if [ -z "$name" ] || [ -z "$host" ]; then
        print_error "Node name and host are required"
        return 1
    fi

    # Check if node already exists
    if node_exists "$name"; then
        print_error "Node '$name' already exists"
        return 1
    fi

    # Test connection to node
    # Resolve IP for connection test to bypass TequilAPI restrictions
    local connection_host=$(resolve_host "$host")
    print_info "Testing connection to $host ($connection_host:$port)..."

    local response=$(curl -s -w "\n%{http_code}" -u "${user}:${pass}" \
        "http://${connection_host}:${port}/healthcheck" 2>&1)

    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    if [ "$http_code" != "200" ]; then
        print_error "Cannot connect to node at ${host}:${port} (HTTP $http_code)"
        print_warning "Please verify the node is running and accessible"
        return 1
    fi

    print_success "Connection successful!"

    # Get node version and identity
    local version=$(echo "$body" | grep -o '"version":"[^"]*"' | cut -d'"' -f4)
    local identity=$(curl -s -u "${user}:${pass}" \
        "http://${connection_host}:${port}/identities" 2>/dev/null | \
        grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)

    print_info "Node version: $version"
    if [ -n "$identity" ]; then
        print_info "Node identity: $identity"
    fi

    # Save node configuration
    echo "${name}|${host}|${port}|${user}|${pass}|${api_key}" >> "$NODES_FILE"
    print_success "Node '$name' added successfully"

    # Onboard if API key provided
    if [ -n "$api_key" ]; then
        onboard_node "$name" "$api_key"
    fi

    return 0
}

remove_node() {
    local name=$1

    if [ -z "$name" ]; then
        print_error "Node name is required"
        return 1
    fi

    if ! node_exists "$name"; then
        print_error "Node '$name' not found"
        return 1
    fi

    # Remove from nodes file
    grep -v "^${name}|" "$NODES_FILE" > "${NODES_FILE}.tmp"
    mv "${NODES_FILE}.tmp" "$NODES_FILE"

    # Remove from onboarded file
    if [ -f "$ONBOARDED_FILE" ]; then
        grep -v "^${name}$" "$ONBOARDED_FILE" > "${ONBOARDED_FILE}.tmp" 2>/dev/null
        mv "${ONBOARDED_FILE}.tmp" "$ONBOARDED_FILE"
    fi

    print_success "Node '$name' removed successfully"
    return 0
}

onboard_node() {
    local name=$1
    local api_key=$2

    if [ -z "$api_key" ]; then
        print_error "API key is required for onboarding"
        return 1
    fi

    local node_info=$(get_node_info "$name")
    if [ -z "$node_info" ]; then
        print_error "Node '$name' not found"
        return 1
    fi

    # Parse node info
    local host=$(echo "$node_info" | cut -d'|' -f2)
    local port=$(echo "$node_info" | cut -d'|' -f3)
    local user=$(echo "$node_info" | cut -d'|' -f4)
    local pass=$(echo "$node_info" | cut -d'|' -f5)

    # Resolve IP
    local connection_host=$(resolve_host "$host")

    print_info "Onboarding node '$name' to Mysterium Network..."

    # Set MMN API key via TequilAPI
    local response=$(curl -s -w "\n%{http_code}" -u "${user}:${pass}" \
        -X POST "http://${connection_host}:${port}/mmn/api-key" \
        -H "Content-Type: application/json" \
        -d "{\"api_key\":\"${api_key}\"}" 2>&1)

    local http_code=$(echo "$response" | tail -n1)

    if [ "$http_code" = "200" ] || [ "$http_code" = "201" ]; then
        print_success "Node onboarded successfully"
        echo "$name" >> "$ONBOARDED_FILE"
        return 0
    else
        print_error "Failed to onboard node (HTTP $http_code)"
        return 1
    fi
}

list_nodes() {
    local nodes=$(get_node_list)

    if [ -z "$nodes" ]; then
        print_warning "No nodes configured"
        return
    fi

    print_section "Configured Nodes"
    echo ""

    while IFS='|' read -r name host port user pass api_key; do
        local onboarded=""
        if grep -q "^${name}$" "$ONBOARDED_FILE" 2>/dev/null; then
            onboarded="${GREEN}[Onboarded]${NC}"
        fi

        echo -e "  ${BOLD}${name}${NC} $onboarded"
        echo -e "    Host: ${host}:${port}"
        echo -e "    Auth: ${user}:${DIM}***${NC}"
        echo ""
    done <<< "$nodes"
}

#####################################################################
# Node Status Functions
#####################################################################

check_node_status() {
    local name=$1
    local node_info=$(get_node_info "$name")

    if [ -z "$node_info" ]; then
        print_error "Node '$name' not found"
        return 1
    fi

    # Parse node info
    local host=$(echo "$node_info" | cut -d'|' -f2)
    local port=$(echo "$node_info" | cut -d'|' -f3)
    local user=$(echo "$node_info" | cut -d'|' -f4)
    local pass=$(echo "$node_info" | cut -d'|' -f5)

    # Resolve IP
    local connection_host=$(resolve_host "$host")

    echo -e "${CYAN}${BOLD}>>> ${name}${NC}"
    echo -e "${CYAN}────────────────────────────────────────${NC}"

    # Get health check
    local response=$(curl -s -u "${user}:${pass}" \
        "http://${connection_host}:${port}/healthcheck" 2>&1)

    if echo "$response" | grep -q '"uptime"'; then
        print_success "Node is healthy"

        local version=$(echo "$response" | grep -o '"version":"[^"]*"' | cut -d'"' -f4)
        local uptime=$(echo "$response" | grep -o '"uptime":"[^"]*"' | cut -d'"' -f4)
        local process=$(echo "$response" | grep -o '"process":[0-9]*' | cut -d':' -f2)

        echo -e "  ${BOLD}Version:${NC} $version"
        echo -e "  ${BOLD}Uptime:${NC} $uptime"
        echo -e "  ${BOLD}Process:${NC} $process"

        # Verbose mode - show additional details
        if [ "$VERBOSE_MODE" = "true" ]; then
            echo ""
            print_info "Fetching detailed information..."

            # Get identity
            local identity=$(curl -s -u "${user}:${pass}" \
                "http://${connection_host}:${port}/identities" 2>/dev/null | \
                grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)

            if [ -n "$identity" ]; then
                echo -e "  ${BOLD}Identity:${NC} $identity"
            fi

            # Get location
            local location=$(curl -s -u "${user}:${pass}" \
                "http://${connection_host}:${port}/location" 2>/dev/null)

            if echo "$location" | grep -q '"ip"'; then
                local ip=$(echo "$location" | grep -o '"ip":"[^"]*"' | cut -d'"' -f4)
                local country=$(echo "$location" | grep -o '"country":"[^"]*"' | cut -d'"' -f4)
                echo -e "  ${BOLD}IP:${NC} $ip"
                echo -e "  ${BOLD}Country:${NC} $country"
            fi

            # Get NAT type
            local nat=$(curl -s -u "${user}:${pass}" \
                "http://${connection_host}:${port}/nat/type" 2>/dev/null | \
                grep -o '"type":"[^"]*"' | cut -d'"' -f4)

            if [ -n "$nat" ]; then
                echo -e "  ${BOLD}NAT Type:${NC} $nat"
            fi

            # Get running services
            local services=$(curl -s -u "${user}:${pass}" \
                "http://${connection_host}:${port}/services" 2>/dev/null)

            local service_count=$(echo "$services" | grep -c '"id":"' 2>/dev/null || echo "0")
            echo -e "  ${BOLD}Running Services:${NC} $service_count"

            if [ "$service_count" -gt 0 ]; then
                echo "$services" | grep -o '"type":"[^"]*"' | cut -d'"' -f4 | while read -r svc; do
                    echo -e "    - $svc"
                done
            fi
        fi
    else
        print_error "Node not responding"
        echo -e "  ${DIM}Response: $response${NC}"
    fi

    echo ""
}

check_all_nodes() {
    local nodes=$(get_node_list)

    if [ -z "$nodes" ]; then
        print_warning "No nodes configured"
        return
    fi

    while IFS='|' read -r name host port user pass api_key; do
        check_node_status "$name"
    done <<< "$nodes"
}

#####################################################################
# Earnings Calculation Functions
#####################################################################

calculate_earnings() {
    local node_name=$1
    local range_seconds=$2 # 0 for all time
    
    local node_info=$(get_node_info "$node_name")
    if [ -z "$node_info" ]; then
        echo "0"
        return
    fi

    # Parse node credentials
    local host=$(echo "$node_info" | cut -d'|' -f2)
    local port=$(echo "$node_info" | cut -d'|' -f3)
    local user=$(echo "$node_info" | cut -d'|' -f4)
    local pass=$(echo "$node_info" | cut -d'|' -f5)

    # Resolve IP
    local connection_host=$(resolve_host "$host")

    # Determine date filter
    local date_from=""
    if [ "$range_seconds" -gt 0 ]; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS date
            date_from=$(date -u -v-${range_seconds}S +%Y-%m-%dT%H:%M:%SZ)
        else
            # Linux date
            date_from=$(date -u -d "@$(($(date +%s) - $range_seconds))" +%Y-%m-%dT%H:%M:%SZ)
        fi
    fi

    local url="http://${connection_host}:${port}/transactor/settle/history?page_size=100&page=1"
    if [ -n "$date_from" ]; then
        url="${url}&date_from=${date_from}"
    fi

    local response=$(curl -s -u "${user}:${pass}" "$url" 2>&1)
    
    # Sum up amounts
    local total_wei=0
    
    # Check if response is valid JSON
    if echo "$response" | grep -q '"items":'; then
         # Extract amounts and sum them using awk to avoid shell loop slowness
        total_wei=$(echo "$response" | grep -o '"amount":[0-9]*' | cut -d':' -f2 | awk '{s+=$1} END {printf "%.0f", s}')
    fi
    
    if [ -z "$total_wei" ]; then
        total_wei=0
    fi

    wei_to_myst "$total_wei"
}

calculate_session_stats() {
    local node_name=$1
    local range_seconds=$2 # 0 for all time
    
    # We fetch all sessions (or last 31 days) and filter in memory using jq
    # Since we can't filter by exact time on API side (only date)
    
    # Calculate cutoff timestamp
    local cutoff_ts=0
    if [ "$range_seconds" -gt 0 ]; then
        cutoff_ts=$(($(date +%s) - $range_seconds))
    fi
    
    # Fetch sessions for last 32 days to be safe if range is small, 
    # or just fetch recent ones. For "Total" we need all.
    # To keep it performant for the summary view, let's limit to last 32 days for the 30d/7d/24h cols
    # For Total, we might need a separate call or just accept 30d limit for now unless requested.
    # But user asked for "Total". 
    # Let's try to fetch 35 days for the columns.
    
    local date_from_35d=""
    if [[ "$OSTYPE" == "darwin"* ]]; then
        date_from_35d=$(date -u -v-35d +%Y-%m-%d)
    else
        date_from_35d=$(date -u -d "35 days ago" +%Y-%m-%d)
    fi
    
    # If range_seconds is 0 (Total), we don't pass date filter to get everything
    local sessions_json=""
    if [ "$range_seconds" -eq 0 ]; then
        sessions_json=$(get_session_history "$node_name" "")
    else
        sessions_json=$(get_session_history "$node_name" "$date_from_35d")
    fi
    
    if [ -z "$sessions_json" ] || [ "$sessions_json" = "[]" ]; then
        echo "0|0" # Count | Amount
        return
    fi
    
    # Use jq to filter and sum
    # input time format: 2026-01-04T06:08:25Z
    # We need to convert to seconds in jq. 
    # jq's `fromdateiso8601` parses ISO 8601
    
    local stats=$(echo "$sessions_json" | jq -r --argjson cutoff "$cutoff_ts" '
        [ .[] | select(.created_at | fromdateiso8601 >= $cutoff) ] | 
        { 
          count: length, 
          tokens: (map(.tokens) | add // 0) 
        } | 
        "\(.count)|\(.tokens)"
    ')
    
    local count=$(echo "$stats" | cut -d'|' -f1)
    local tokens_wei=$(echo "$stats" | cut -d'|' -f2)
    local tokens_myst=$(wei_to_myst "$tokens_wei")
    
    echo "${count}|${tokens_myst}"
}

view_sessions_summary() {
    print_header
    print_section "Session Summary (Count | MYST Earned)"
    echo ""

    local nodes=$(get_node_list)
    if [ -z "$nodes" ]; then
        print_warning "No nodes configured"
        echo ""
        read -p "Press Enter to continue..."
        return
    fi

    # Header
    printf "%-12s %-24s %-22s %-22s\n" "NODE" "24H" "7D" "30D"
    echo "────────────────────────────────────────────────────────────────────────────────"

    while IFS='|' read -r name host port user pass api_key; do
        # We need to compute stats. 
        # To avoid multiple API calls per row, let's fetch once for the last 35 days 
        # and reuse the JSON for 24h, 7d, 30d.
        
        local date_from_35d=""
        if [[ "$OSTYPE" == "darwin"* ]]; then
            date_from_35d=$(date -u -v-35d +%Y-%m-%d)
        else
            date_from_35d=$(date -u -d "35 days ago" +%Y-%m-%d)
        fi
        
        local sessions_json=$(get_session_history "$name" "$date_from_35d")
        
        if [ -z "$sessions_json" ] || [ "$sessions_json" = "[]" ]; then
             printf "%-12s %-24s %-22s %-22s\n" "${name:0:11}" "0 | 0.00000000" "0 | 0.00000000" "0 | 0.00000000"
             continue
        fi

        # Function to calc stats from existing json
        calc_from_json() {
            local seconds=$1
            local cutoff=$(($(date +%s) - $seconds))
            echo "$sessions_json" | jq -r --argjson cutoff "$cutoff" '
                [ .[] | select(.created_at | fromdateiso8601 >= $cutoff) ] | 
                { count: length, tokens: (map(.tokens) | add // 0) } | 
                "\(.count)|\(.tokens)"
            '
        }
        
        # 24H
        local s24=$(calc_from_json 86400)
        local c24=$(echo "$s24" | cut -d'|' -f1)
        local t24=$(wei_to_myst "$(echo "$s24" | cut -d'|' -f2)")
        t24=$(printf "%.8f" $t24)
        
        # 7D
        local s7d=$(calc_from_json 604800)
        local c7d=$(echo "$s7d" | cut -d'|' -f1)
        local t7d=$(wei_to_myst "$(echo "$s7d" | cut -d'|' -f2)")
        t7d=$(printf "%.8f" $t7d)
        
        # 30D
        local s30d=$(calc_from_json 2592000)
        local c30d=$(echo "$s30d" | cut -d'|' -f1)
        local t30d=$(wei_to_myst "$(echo "$s30d" | cut -d'|' -f2)")
        t30d=$(printf "%.8f" $t30d)
        
        printf "%-12s %-24s %-22s %-22s\n" \
            "${name:0:11}" "${c24} | ${t24}" "${c7d} | ${t7d}" "${c30d} | ${t30d}"
            
    done <<< "$nodes"
    
    echo ""
}

view_earnings_summary() {
    print_header
    print_section "Earnings Summary (MYST)"
    echo ""

    local nodes=$(get_node_list)
    if [ -z "$nodes" ]; then
        print_warning "No nodes configured"
        echo ""
        read -p "Press Enter to continue..."
        return
    fi

    printf "%-20s %-12s %-12s %-12s %-12s\n" "NODE" "24H" "7D" "30D" "TOTAL"
    echo "──────────────────────────────────────────────────────────────────────"

    while IFS='|' read -r name host port user pass api_key; do
        # Calculate time ranges
        local e24=$(printf "%.8f" $(calculate_earnings "$name" 86400))
        local e7d=$(printf "%.8f" $(calculate_earnings "$name" 604800))
        local e30d=$(printf "%.8f" $(calculate_earnings "$name" 2592000))
        local etotal=$(printf "%.8f" $(calculate_earnings "$name" 0))

        printf "%-20s %-12s %-12s %-12s %-12s\n" \
            "${name:0:19}" "$e24" "$e7d" "$e30d" "$etotal"
            
    done <<< "$nodes"
    
    echo ""
}

#####################################################################
# Transaction Download Functions
#####################################################################

wei_to_myst() {
    local wei=$1
    if [ -z "$wei" ] || [ "$wei" = "0" ]; then
        echo "0"
        return
    fi
    # Convert wei to MYST (divide by 10^18)
    echo "scale=18; $wei / 1000000000000000000" | bc 2>/dev/null || echo "0"
}

validate_rfc3339_date() {
    local date=$1
    # Basic validation: YYYY-MM-DDTHH:MM:SSZ format
    if ! echo "$date" | grep -qE '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$'; then
        return 1
    fi
    return 0
}

get_node_identity() {
    local node_name=$1

    # Get node info from config
    local node_info=$(get_node_info "$node_name")
    if [ -z "$node_info" ]; then
        return 1
    fi

    # Parse node credentials
    local host=$(echo "$node_info" | cut -d'|' -f2)
    local port=$(echo "$node_info" | cut -d'|' -f3)
    local user=$(echo "$node_info" | cut -d'|' -f4)
    local pass=$(echo "$node_info" | cut -d'|' -f5)

    # Resolve IP
    local connection_host=$(resolve_host "$host")

    # Fetch identities from API
    local response=$(curl -s -w "\n%{http_code}" -u "${user}:${pass}" \
        "http://${connection_host}:${port}/identities" 2>&1)
    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    if [ "$http_code" != "200" ]; then
        return 1
    fi

    # Extract first identity ID
    local identity=$(echo "$body" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
    echo "$identity"
}

get_settlement_history() {
    local node_name=$1
    local date_from=$2
    local date_to=$3

    # Get node info from config
    local node_info=$(get_node_info "$node_name")
    if [ -z "$node_info" ]; then
        return 1
    fi

    # Parse node credentials
    local host=$(echo "$node_info" | cut -d'|' -f2)
    local port=$(echo "$node_info" | cut -d'|' -f3)
    local user=$(echo "$node_info" | cut -d'|' -f4)
    local pass=$(echo "$node_info" | cut -d'|' -f5)

    # Resolve IP
    local connection_host=$(resolve_host "$host")

    local all_items="[]"
    local page=1
    local total_pages=1

    # Fetch all pages
    while [ $page -le $total_pages ]; do
        local url="http://${connection_host}:${port}/transactor/settle/history?page_size=50&page=${page}"

        # Add date filters if provided
        if [ -n "$date_from" ]; then
            url="${url}&date_from=${date_from}"
        fi
        if [ -n "$date_to" ]; then
            url="${url}&date_to=${date_to}"
        fi

        local response=$(curl -s -w "\n%{http_code}" -u "${user}:${pass}" "$url" 2>&1)
        local http_code=$(echo "$response" | tail -n1)
        local body=$(echo "$response" | sed '$d')

        if [ "$http_code" != "200" ]; then
            print_error "Failed to fetch settlement history (HTTP $http_code)"
            return 1
        fi

        # Extract total_pages from first page only
        if [ $page -eq 1 ]; then
            total_pages=$(echo "$body" | grep -o '"total_pages":[0-9]*' | cut -d':' -f2)
            [ -z "$total_pages" ] && total_pages=1
        fi

        # Extract and concatenate items
        local items=$(echo "$body" | grep -o '"items":\[.*\]' | sed 's/"items"://')

        # If not first page, merge arrays
        if [ $page -eq 1 ]; then
            all_items="$items"
        else
            # Remove closing bracket from all_items and opening from items, merge
            all_items=$(echo "$all_items" | sed '$ s/]$/,/')
            items=$(echo "$items" | sed 's/^\[//')
            all_items="${all_items}${items}"
        fi

        ((page++))
    done

    echo "$all_items"
}

get_session_history() {
    local node_name=$1
    local date_from=$2 # YYYY-MM-DD
    local date_to=$3   # YYYY-MM-DD

    # Get node info from config
    local node_info=$(get_node_info "$node_name")
    if [ -z "$node_info" ]; then
        return 1
    fi

    # Parse node credentials
    local host=$(echo "$node_info" | cut -d'|' -f2)
    local port=$(echo "$node_info" | cut -d'|' -f3)
    local user=$(echo "$node_info" | cut -d'|' -f4)
    local pass=$(echo "$node_info" | cut -d'|' -f5)

    # Resolve IP
    local connection_host=$(resolve_host "$host")

    local all_items="[]"
    local page=1
    local total_pages=1

    # Fetch all pages
    while [ $page -le $total_pages ]; do
        local url="http://${connection_host}:${port}/sessions?page_size=100&page=${page}"

        # Add date filters if provided
        if [ -n "$date_from" ]; then
            url="${url}&date_from=${date_from}"
        fi
        if [ -n "$date_to" ]; then
            url="${url}&date_to=${date_to}"
        fi

        local response=$(curl -s -u "${user}:${pass}" "$url" 2>&1)
        
        # Check if response is valid JSON
        if ! echo "$response" | grep -q '"items":'; then
            print_error "Failed to fetch sessions"
            return 1
        fi

        # Extract total_pages from first page only
        if [ $page -eq 1 ]; then
            total_pages=$(echo "$response" | grep -o '"total_pages":[0-9]*' | cut -d':' -f2)
            [ -z "$total_pages" ] && total_pages=1
        fi

        # Extract and concatenate items
        local items=$(echo "$response" | grep -o '"items":\[.*\]' | sed 's/"items"://')
        # Handle trailing metadata by cutting at the last ]
        items=${items%\}*}
        
        # If the grep captured too much (e.g. metadata at end), clean it
        # Actually, let's use a simpler approach if jq is available (it is per dependencies)
        if command -v jq &> /dev/null; then
             items=$(echo "$response" | jq -c '.items')
        fi

        # If not first page, merge arrays
        if [ $page -eq 1 ]; then
            all_items="$items"
        else
            # Remove closing bracket from all_items and opening from items, merge
            # Assuming format is [ ... ]
            all_items=$(echo "$all_items" | sed 's/]$/,/')
            items=$(echo "$items" | sed 's/^\[//')
            all_items="${all_items}${items}"
        fi

        ((page++))
    done

    echo "$all_items"
}

get_transactor_fees() {
    local node_name=$1

    # Get node info from config
    local node_info=$(get_node_info "$node_name")
    if [ -z "$node_info" ]; then
        return 1
    fi

    # Parse node credentials
    local host=$(echo "$node_info" | cut -d'|' -f2)
    local port=$(echo "$node_info" | cut -d'|' -f3)
    local user=$(echo "$node_info" | cut -d'|' -f4)
    local pass=$(echo "$node_info" | cut -d'|' -f5)

    # Resolve IP
    local connection_host=$(resolve_host "$host")

    # Fetch fees from API (try v2 first, fallback to v1)
    local response=$(curl -s -w "\n%{http_code}" -u "${user}:${pass}" \
        "http://${connection_host}:${port}/v2/transactor/fees" 2>&1)
    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    if [ "$http_code" = "200" ]; then
        echo "$body"
        return 0
    fi

    # Fallback to v1 endpoint
    response=$(curl -s -w "\n%{http_code}" -u "${user}:${pass}" \
        "http://${connection_host}:${port}/transactor/fees" 2>&1)
    http_code=$(echo "$response" | tail -n1)
    body=$(echo "$response" | sed '$d')

    if [ "$http_code" = "200" ]; then
        echo "$body"
        return 0
    fi

    # Return empty object if both fail
    echo "{}"
}

get_identity_beneficiary() {
    local node_name=$1
    local identity_id=$2

    if [ -z "$identity_id" ]; then
        return 1
    fi

    # Get node info from config
    local node_info=$(get_node_info "$node_name")
    if [ -z "$node_info" ]; then
        return 1
    fi

    # Parse node credentials
    local host=$(echo "$node_info" | cut -d'|' -f2)
    local port=$(echo "$node_info" | cut -d'|' -f3)
    local user=$(echo "$node_info" | cut -d'|' -f4)
    local pass=$(echo "$node_info" | cut -d'|' -f5)

    # Resolve IP
    local connection_host=$(resolve_host "$host")

    # Fetch beneficiary from API
    local response=$(curl -s -w "\n%{http_code}" -u "${user}:${pass}" \
        "http://${connection_host}:${port}/identities/${identity_id}/beneficiary" 2>&1)
    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    if [ "$http_code" != "200" ]; then
        return 1
    fi

    echo "$body"
}

export_transactions_csv() {
    local node_name=$1
    local output_file=$2
    local settlements_json=$3
    local fees_json=$4
    local beneficiary=$5

    # CSV header
    {
        echo "Date,Type,Amount (MYST),Fees (MYST),Beneficiary,Hermes ID,TX Hash,Status,Block Explorer"

        # Process each settlement record
        local item_count=0
        local total_amount_wei=0
        local total_fees_wei=0
        local settlement_count=0
        local withdrawal_count=0

        # Parse and output each settlement item
        echo "$settlements_json" | grep -o '{[^{}]*"tx_hash"[^{}]*}' | while IFS= read -r item; do
            # Extract fields with safe grep
            local date=$(echo "$item" | grep -o '"settled_at":"[^"]*"' | cut -d'"' -f4)
            local amount=$(echo "$item" | grep -o '"amount":"[^"]*"' | cut -d'"' -f4)
            local fees=$(echo "$item" | grep -o '"fees":"[^"]*"' | cut -d'"' -f4)
            local is_withdrawal=$(echo "$item" | grep -o '"is_withdrawal":[^,}]*' | cut -d':' -f2)
            local hermes_id=$(echo "$item" | grep -o '"hermes_id":"[^"]*"' | cut -d'"' -f4)
            local tx_hash=$(echo "$item" | grep -o '"tx_hash":"[^"]*"' | cut -d'"' -f4)
            local error=$(echo "$item" | grep -o '"error":"[^"]*"' | cut -d'"' -f4)
            local block_explorer=$(echo "$item" | grep -o '"block_explorer_url":"[^"]*"' | cut -d'"' -f4)

            # Format date (convert RFC3339 to human-readable)
            date=$(echo "$date" | cut -d'T' -f1,2 | tr 'T' ' ')

            # Convert wei to MYST
            local amount_myst=$(wei_to_myst "$amount")
            local fees_myst=$(wei_to_myst "$fees")

            # Determine type
            local type="settlement"
            if [ "$is_withdrawal" = "true" ]; then
                type="withdrawal"
                ((withdrawal_count++))
            else
                ((settlement_count++))
            fi

            # Determine status
            local status="success"
            if [ -n "$error" ] && [ "$error" != "null" ]; then
                status="failed: $error"
            fi

            # Output CSV row
            echo "\"$date\",\"$type\",\"$amount_myst\",\"$fees_myst\",\"$beneficiary\",\"$hermes_id\",\"$tx_hash\",\"$status\",\"$block_explorer\""

            # Accumulate totals
            total_amount_wei=$(echo "$total_amount_wei + $amount" | bc)
            total_fees_wei=$(echo "$total_fees_wei + $fees" | bc)
            ((item_count++))
        done

        # Add summary footer
        if [ $item_count -gt 0 ]; then
            echo ""
            echo "SUMMARY"
            echo "Total Settlements,$settlement_count"
            echo "Total Withdrawals,$withdrawal_count"
            local total_myst=$(wei_to_myst "$total_amount_wei")
            echo "Total Amount (MYST),$total_myst"
        fi

    } > "$output_file"
}

export_transactions_json() {
    local node_name=$1
    local output_file=$2
    local settlements_json=$3
    local fees_json=$4
    local beneficiary=$5
    local date_from=$6
    local date_to=$7

    local export_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    # Build JSON structure manually
    cat > "$output_file" <<EOFJ
{
  "metadata": {
    "node_name": "$node_name",
    "export_timestamp": "$export_timestamp",
    "date_range": {
      "from": "${date_from:-null}",
      "to": "${date_to:-null}"
    }
  },
  "settlements": $settlements_json,
  "fees": $fees_json,
  "beneficiary": {
    "address": "$beneficiary"
  }
}
EOFJ
}

export_sessions_csv() {
    local node_name=$1
    local output_file=$2
    local sessions_json=$3

    # CSV header
    {
        echo "ID,Created At,Consumer ID,Service Type,Consumer Country,Duration (s),Bytes Received,Bytes Sent,Tokens (MYST),Status"

        # Process each session record
        echo "$sessions_json" | jq -c '.[]' | while read -r item; do
            local id=$(echo "$item" | jq -r '.id')
            local created_at=$(echo "$item" | jq -r '.created_at')
            local consumer_id=$(echo "$item" | jq -r '.consumer_id')
            local service_type=$(echo "$item" | jq -r '.service_type')
            local consumer_country=$(echo "$item" | jq -r '.consumer_country')
            local duration=$(echo "$item" | jq -r '.duration')
            local bytes_received=$(echo "$item" | jq -r '.bytes_received')
            local bytes_sent=$(echo "$item" | jq -r '.bytes_sent')
            local tokens_wei=$(echo "$item" | jq -r '.tokens')
            local status=$(echo "$item" | jq -r '.status')

            # Convert wei to MYST
            local tokens_myst=$(wei_to_myst "$tokens_wei")

            # Output CSV row
            echo "\"$id\",\"$created_at\",\"$consumer_id\",\"$service_type\",\"$consumer_country\",\"$duration\",\"$bytes_received\",\"$bytes_sent\",\"$tokens_myst\",\"$status\""
        done

    } > "$output_file"
}

export_sessions_json() {
    local node_name=$1
    local output_file=$2
    local sessions_json=$3
    local date_from=$4
    local date_to=$5

    local export_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    # Build JSON structure
    cat > "$output_file" <<EOFJ
{
  "metadata": {
    "node_name": "$node_name",
    "export_timestamp": "$export_timestamp",
    "date_range": {
      "from": "${date_from:-null}",
      "to": "${date_to:-null}"
    }
  },
  "sessions": $sessions_json
}
EOFJ
}

download_transactions() {
    local node_name=$1
    local format=${2:-both}
    local date_from=$3
    local date_to=$4
    local output_path=${5:-"$HOME/.mystnodes/exports"}

    # Validate inputs
    if [ -z "$node_name" ]; then
        print_error "Node name is required"
        return 1
    fi

    if ! node_exists "$node_name"; then
        print_error "Node '$node_name' not found"
        print_info "Available nodes:"
        get_node_list | cut -d'|' -f1 | sed 's/^/  /'
        return 1
    fi

    # Validate format
    case "$format" in
        csv|json|both) ;;
        *)
            print_error "Invalid format: $format (must be csv, json, or both)"
            return 1
            ;;
    esac

    # Validate dates if provided
    if [ -n "$date_from" ] && ! validate_rfc3339_date "$date_from"; then
        print_error "Invalid date format for --from: $date_from"
        print_info "Expected format: YYYY-MM-DDTHH:MM:SSZ (e.g., 2025-01-01T00:00:00Z)"
        return 1
    fi

    if [ -n "$date_to" ] && ! validate_rfc3339_date "$date_to"; then
        print_error "Invalid date format for --to: $date_to"
        print_info "Expected format: YYYY-MM-DDTHH:MM:SSZ (e.g., 2025-12-31T23:59:59Z)"
        return 1
    fi

    # Create exports directory
    if ! mkdir -p "$output_path" 2>/dev/null; then
        print_error "Failed to create export directory: $output_path"
        return 1
    fi

    print_info "Fetching transaction data for node '$node_name'..."

    # Get identity
    print_info "Fetching node identity..."
    local identity=$(get_node_identity "$node_name")
    if [ -z "$identity" ]; then
        print_error "Failed to get node identity"
        return 1
    fi

    # Get settlement history
    print_info "Fetching settlement history..."
    local settlements=$(get_settlement_history "$node_name" "$date_from" "$date_to")
    if [ -z "$settlements" ] || [ "$settlements" = "[]" ]; then
        print_warning "No transactions found for node '$node_name'"
        if [ -n "$date_from" ] || [ -n "$date_to" ]; then
            print_info "Try adjusting date range"
        fi
        return 0
    fi

    # Get transaction fees
    print_info "Fetching transaction fees..."
    local fees=$(get_transactor_fees "$node_name")

    # Get beneficiary address
    print_info "Fetching beneficiary address..."
    local beneficiary_json=$(get_identity_beneficiary "$node_name" "$identity")
    local beneficiary="unknown"
    if [ -n "$beneficiary_json" ]; then
        beneficiary=$(echo "$beneficiary_json" | grep -o '"beneficiary":"[^"]*"' | cut -d'"' -f4)
    fi

    # Count transactions
    local tx_count=$(echo "$settlements" | grep -c '"tx_hash"' || echo "0")
    print_success "Found $tx_count transactions"

    # Generate timestamp for filenames
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local base_filename="${node_name}_transactions_${timestamp}"

    # Export files
    local csv_file=""
    local json_file=""

    case "$format" in
        csv)
            csv_file="${output_path}/${base_filename}.csv"
            print_info "Generating CSV export..."
            export_transactions_csv "$node_name" "$csv_file" "$settlements" "$fees" "$beneficiary"
            if [ -f "$csv_file" ]; then
                print_success "CSV export created: $csv_file"
            fi
            ;;
        json)
            json_file="${output_path}/${base_filename}.json"
            print_info "Generating JSON export..."
            export_transactions_json "$node_name" "$json_file" "$settlements" "$fees" "$beneficiary" "$date_from" "$date_to"
            if [ -f "$json_file" ]; then
                print_success "JSON export created: $json_file"
            fi
            ;;
        both)
            csv_file="${output_path}/${base_filename}.csv"
            json_file="${output_path}/${base_filename}.json"
            print_info "Generating CSV export..."
            export_transactions_csv "$node_name" "$csv_file" "$settlements" "$fees" "$beneficiary"
            print_info "Generating JSON export..."
            export_transactions_json "$node_name" "$json_file" "$settlements" "$fees" "$beneficiary" "$date_from" "$date_to"
            if [ -f "$csv_file" ]; then
                print_success "CSV export created: $csv_file"
            fi
            if [ -f "$json_file" ]; then
                print_success "JSON export created: $json_file"
            fi
            ;;
    esac

    print_success "Export completed successfully"
    return 0
}

download_sessions() {
    local node_name=$1
    local format=${2:-both}
    local date_from=$3
    local date_to=$4
    local output_path=${5:-"$HOME/.mystnodes/exports"}

    # Validate inputs
    if [ -z "$node_name" ]; then
        print_error "Node name is required"
        return 1
    fi

    if ! node_exists "$node_name"; then
        print_error "Node '$node_name' not found"
        return 1
    fi

    # Create exports directory
    if ! mkdir -p "$output_path" 2>/dev/null; then
        print_error "Failed to create export directory: $output_path"
        return 1
    fi

    print_info "Fetching session history for node '$node_name'..."

    # Extract YYYY-MM-DD from full timestamps if provided
    local date_from_short=""
    local date_to_short=""
    if [ -n "$date_from" ]; then
        date_from_short=$(echo "$date_from" | cut -d'T' -f1)
    fi
    if [ -n "$date_to" ]; then
        date_to_short=$(echo "$date_to" | cut -d'T' -f1)
    fi

    local sessions=$(get_session_history "$node_name" "$date_from_short" "$date_to_short")
    
    if [ -z "$sessions" ] || [ "$sessions" = "[]" ]; then
        print_warning "No sessions found for node '$node_name'"
        return 0
    fi

    # Count sessions
    local count=$(echo "$sessions" | jq '. | length')
    print_success "Found $count sessions"

    # Generate timestamp for filenames
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local base_filename="${node_name}_sessions_${timestamp}"

    # Export files
    local csv_file=""
    local json_file=""

    case "$format" in
        csv)
            csv_file="${output_path}/${base_filename}.csv"
            print_info "Generating CSV export..."
            export_sessions_csv "$node_name" "$csv_file" "$sessions"
            if [ -f "$csv_file" ]; then
                print_success "CSV export created: $csv_file"
            fi
            ;;
        json)
            json_file="${output_path}/${base_filename}.json"
            print_info "Generating JSON export..."
            export_sessions_json "$node_name" "$json_file" "$sessions" "$date_from" "$date_to"
            if [ -f "$json_file" ]; then
                print_success "JSON export created: $json_file"
            fi
            ;;
        both)
            csv_file="${output_path}/${base_filename}.csv"
            json_file="${output_path}/${base_filename}.json"
            print_info "Generating CSV export..."
            export_sessions_csv "$node_name" "$csv_file" "$sessions"
            print_info "Generating JSON export..."
            export_sessions_json "$node_name" "$json_file" "$sessions" "$date_from" "$date_to"
            if [ -f "$csv_file" ]; then
                print_success "CSV export created: $csv_file"
            fi
            if [ -f "$json_file" ]; then
                print_success "JSON export created: $json_file"
            fi
            ;;
    esac

    print_success "Export completed successfully"
    return 0
}

#####################################################################
# Interactive Menu Functions
#####################################################################

show_menu() {
    print_header

    local menu_items=(
        "View All Nodes Status"
        "Add New Node"
        "Remove Node"
        "List Configured Nodes"
        "Download Transaction Records"
        "View Earnings Summary"
        "Download Session Records"
        "View Session Summary"
        "Toggle Verbose Mode (Currently: $VERBOSE_MODE)"
        "Exit"
    )

    MENU_SIZE=${#menu_items[@]}

    echo -e "${BOLD}Main Menu${NC}"
    echo ""

    for i in "${!menu_items[@]}"; do
        if [ $i -eq $MENU_SELECTED ]; then
            echo -e "  ${GREEN}▶ ${menu_items[$i]}${NC}"
        else
            echo -e "    ${menu_items[$i]}"
        fi
    done

    echo ""
    echo -e "${DIM}Use ↑/↓ arrow keys to navigate, Enter to select${NC}"
}

read_menu_input() {
    local key
    read -rsn1 key

    if [ "$key" = $'\x1b' ]; then
        read -rsn2 key
        case "$key" in
            '[A') # Up arrow
                ((MENU_SELECTED--))
                if [ $MENU_SELECTED -lt 0 ]; then
                    MENU_SELECTED=$((MENU_SIZE - 1))
                fi
                ;;
            '[B') # Down arrow
                ((MENU_SELECTED++))
                if [ $MENU_SELECTED -ge $MENU_SIZE ]; then
                    MENU_SELECTED=0
                fi
                ;;
        esac
        return 1
    elif [ "$key" = "" ]; then
        # Enter key pressed
        return 0
    fi

    return 1
}

handle_menu_selection() {
    case $MENU_SELECTED in
        0) # View All Nodes Status
            print_header
            print_section "All Nodes Status"
            echo ""
            check_all_nodes
            echo ""
            read -p "Press Enter to continue..."
            ;;
        1) # Add New Node
            print_header
            print_section "Add New Node"
            echo ""

            read -p "Node name: " node_name
            read -p "Host (IP or hostname.local): " node_host
            read -p "Port [$DEFAULT_PORT]: " node_port
            node_port=${node_port:-$DEFAULT_PORT}
            read -p "Username [$DEFAULT_USER]: " node_user
            node_user=${node_user:-$DEFAULT_USER}
            read -s -p "Password [$DEFAULT_PASS]: " node_pass
            echo ""
            node_pass=${node_pass:-$DEFAULT_PASS}
            read -p "MMN API Key (optional, press Enter to skip): " api_key

            echo ""
            add_node "$node_name" "$node_host" "$node_port" "$node_user" "$node_pass" "$api_key"
            echo ""
            read -p "Press Enter to continue..."
            ;;
        2) # Remove Node
            print_header
            print_section "Remove Node"
            echo ""
            list_nodes
            echo ""
            read -p "Node name to remove: " node_name
            echo ""
            read -p "Are you sure you want to remove '$node_name'? (y/N): " confirm
            if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                remove_node "$node_name"
            else
                print_info "Removal cancelled"
            fi
            echo ""
            read -p "Press Enter to continue..."
            ;;
        3) # List Configured Nodes
            print_header
            list_nodes
            echo ""
            read -p "Press Enter to continue..."
            ;;
        4) # Download Transaction Records
            print_header
            print_section "Download Transaction Records"
            echo ""

            # List nodes for selection
            local nodes=$(get_node_list)
            if [ -z "$nodes" ]; then
                print_warning "No nodes configured"
                echo ""
                read -p "Press Enter to continue..."
                return
            fi

            echo "Available nodes:"
            echo ""
            local i=1
            while IFS='|' read -r name host port user pass api_key; do
                echo "  $i) $name"
                ((i++))
            done <<< "$nodes"
            echo ""

            read -p "Select node number: " node_num

            # Get node name from selection
            local selected_node=$(echo "$nodes" | sed -n "${node_num}p" | cut -d'|' -f1)

            if [ -z "$selected_node" ]; then
                print_error "Invalid selection"
                echo ""
                read -p "Press Enter to continue..."
                return
            fi

            # Prompt for format
            echo ""
            echo "Export format:"
            echo "  1) CSV only"
            echo "  2) JSON only"
            echo "  3) Both (default)"
            echo ""
            read -p "Select format [3]: " format_choice
            format_choice=${format_choice:-3}

            local format="both"
            case "$format_choice" in
                1) format="csv" ;;
                2) format="json" ;;
                3) format="both" ;;
            esac

            # Optional date range
            echo ""
            read -p "Filter by date range? (y/N): " use_dates
            local date_from=""
            local date_to=""

            if [ "$use_dates" = "y" ] || [ "$use_dates" = "Y" ]; then
                read -p "From date (YYYY-MM-DDTHH:MM:SSZ or press Enter to skip): " date_from
                read -p "To date (YYYY-MM-DDTHH:MM:SSZ or press Enter to skip): " date_to
            fi

            echo ""
            download_transactions "$selected_node" "$format" "$date_from" "$date_to"
            echo ""
            read -p "Press Enter to continue..."
            ;;
        5) # View Earnings Summary
            view_earnings_summary
            read -p "Press Enter to continue..."
            ;;
        6) # Download Session Records
            print_header
            print_section "Download Session Records"
            echo ""

            # List nodes for selection
            local nodes=$(get_node_list)
            if [ -z "$nodes" ]; then
                print_warning "No nodes configured"
                echo ""
                read -p "Press Enter to continue..."
                return
            fi

            echo "Available nodes:"
            echo ""
            local i=1
            while IFS='|' read -r name host port user pass api_key; do
                echo "  $i) $name"
                ((i++))
            done <<< "$nodes"
            echo ""

            read -p "Select node number: " node_num

            # Get node name from selection
            local selected_node=$(echo "$nodes" | sed -n "${node_num}p" | cut -d'|' -f1)

            if [ -z "$selected_node" ]; then
                print_error "Invalid selection"
                echo ""
                read -p "Press Enter to continue..."
                return
            fi

            # Prompt for format
            echo ""
            echo "Export format:"
            echo "  1) CSV only"
            echo "  2) JSON only"
            echo "  3) Both (default)"
            echo ""
            read -p "Select format [3]: " format_choice
            format_choice=${format_choice:-3}

            local format="both"
            case "$format_choice" in
                1) format="csv" ;;
                2) format="json" ;;
                3) format="both" ;;
            esac

            # Optional date range
            echo ""
            read -p "Filter by date range? (y/N): " use_dates
            local date_from=""
            local date_to=""

            if [ "$use_dates" = "y" ] || [ "$use_dates" = "Y" ]; then
                read -p "From date (YYYY-MM-DD or press Enter to skip): " date_from
                read -p "To date (YYYY-MM-DD or press Enter to skip): " date_to
            fi

            echo ""
            download_sessions "$selected_node" "$format" "$date_from" "$date_to"
            echo ""
            read -p "Press Enter to continue..."
            ;;
        7) # View Session Summary
            view_sessions_summary
            read -p "Press Enter to continue..."
            ;;
        8) # Toggle Verbose Mode
            if [ "$VERBOSE_MODE" = "true" ]; then
                VERBOSE_MODE=false
                print_info "Verbose mode disabled"
            else
                VERBOSE_MODE=true
                print_info "Verbose mode enabled"
            fi
            save_config
            sleep 1
            ;;
        9) # Exit
            print_header
            echo -e "${GREEN}Thank you for using MystNodes!${NC}"
            echo ""
            exit 0
            ;;
    esac
}

interactive_mode() {
    init_config

    while true; do
        show_menu
        read_menu_input
        if [ $? -eq 0 ]; then
            handle_menu_selection
        fi
    done
}

#####################################################################
# CLI Mode Functions
#####################################################################

run_cli_mode() {
    init_config

    local command=$1
    shift

    case "$command" in
        status)
            local target=${1:-all}
            if [ "$target" = "all" ]; then
                check_all_nodes
            else
                check_node_status "$target"
            fi
            ;;
        add)
            local name=$1
            local host=$2
            local port=${3:-$DEFAULT_PORT}
            local user=${4:-$DEFAULT_USER}
            local pass=${5:-$DEFAULT_PASS}
            local api_key=$6
            add_node "$name" "$host" "$port" "$user" "$pass" "$api_key"
            ;;
        remove)
            local name=$1
            remove_node "$name"
            ;;
        list)
            list_nodes
            ;;
        verbose)
            local mode=${1:-toggle}
            case "$mode" in
                on)
                    VERBOSE_MODE=true
                    save_config
                    print_success "Verbose mode enabled"
                    ;;
                off)
                    VERBOSE_MODE=false
                    save_config
                    print_success "Verbose mode disabled"
                    ;;
                toggle)
                    if [ "$VERBOSE_MODE" = "true" ]; then
                        VERBOSE_MODE=false
                        print_success "Verbose mode disabled"
                    else
                        VERBOSE_MODE=true
                        print_success "Verbose mode enabled"
                    fi
                    save_config
                    ;;
            esac
            ;;
        onboard)
            local name=$1
            local api_key=$2
            onboard_node "$name" "$api_key"
            ;;
        download-transactions)
            local node=$1
            shift
            local format="both"
            local date_from=""
            local date_to=""
            local output=""

            # Parse flags
            while [ $# -gt 0 ]; do
                case "$1" in
                    --format)
                        format=$2
                        shift 2
                        ;;
                    --from)
                        date_from=$2
                        shift 2
                        ;;
                    --to)
                        date_to=$2
                        shift 2
                        ;;
                    --output)
                        output=$2
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [ -z "$node" ]; then
                print_error "Node name required"
                echo ""
                show_help
                exit 1
            fi

            download_transactions "$node" "$format" "$date_from" "$date_to" "$output"
            ;;
        earnings)
            view_earnings_summary
            ;;
        download-sessions)
            local node=$1
            shift
            local format="both"
            local date_from=""
            local date_to=""
            local output=""

            # Parse flags
            while [ $# -gt 0 ]; do
                case "$1" in
                    --format)
                        format=$2
                        shift 2
                        ;;
                    --from)
                        date_from=$2
                        shift 2
                        ;;
                    --to)
                        date_to=$2
                        shift 2
                        ;;
                    --output)
                        output=$2
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [ -z "$node" ]; then
                print_error "Node name required"
                echo ""
                show_help
                exit 1
            fi

            download_sessions "$node" "$format" "$date_from" "$date_to" "$output"
            ;;
        sessions)
            view_sessions_summary
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo -e "${RED}Unknown command: $command${NC}"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

show_help() {
    cat <<EOF
${BOLD}MystNodes - Mysterium Network Node Manager${NC}

${BOLD}USAGE:${NC}
  my_myst_nodes                       Start interactive menu mode
  my_myst_nodes COMMAND [ARGS...]     Run CLI command

${BOLD}COMMANDS:${NC}
  status [all|NODE]                   Check node status
  add NAME HOST [PORT] [USER] [PASS] [API_KEY]
                                      Add new node
  remove NODE                         Remove node
  list                                List all configured nodes
  verbose [on|off|toggle]             Toggle verbose mode
  onboard NODE API_KEY                Onboard node to MMN
  download-transactions NODE [OPTIONS]
                                      Download transaction records
  earnings                            View earnings summary for all nodes
  download-sessions NODE [OPTIONS]    Download session records
  sessions                            View session summary for all nodes
  help                                Show this help message

${BOLD}EXAMPLES:${NC}
  # Interactive mode
  my_myst_nodes

  # Check all nodes
  my_myst_nodes status all

  # Check specific node
  my_myst_nodes status mynode

  # Add node with defaults
  my_myst_nodes add mynode 192.168.1.100

  # Add node with custom port
  my_myst_nodes add mynode 192.168.1.100 4050

  # Add node with avahi hostname
  my_myst_nodes add hill hill.local 4050

  # Add node with API key for onboarding
  my_myst_nodes add mynode 192.168.1.100 4050 myst mystberry YOUR_API_KEY

  # Remove node
  my_myst_nodes remove mynode

  # List all nodes
  my_myst_nodes list

  # Enable verbose mode
  my_myst_nodes verbose on

  # Download all transactions (both CSV and JSON)
  my_myst_nodes download-transactions orion

  # Download CSV only
  my_myst_nodes download-transactions orion --format csv

  # Download JSON with date range
  my_myst_nodes download-transactions orion --format json \
    --from 2025-01-01T00:00:00Z --to 2025-12-31T23:59:59Z

  # Download to custom directory
  my_myst_nodes download-transactions orion --output /tmp/exports

${BOLD}DOWNLOAD OPTIONS:${NC}
  --format csv|json|both              Export format (default: both)
  --from DATE                         Filter from date (RFC3339 format)
  --to DATE                           Filter to date (RFC3339 format)
  --output PATH                       Custom output directory

${BOLD}CONFIGURATION:${NC}
  Config directory: ~/.mystnodes/
  Nodes file:       ~/.mystnodes/nodes
  Config file:      ~/.mystnodes/config
  Onboarded file:   ~/.mystnodes/onboarded
  Exports directory: ~/.mystnodes/exports/

${BOLD}NODE FORMAT:${NC}
  NAME|HOST|PORT|USER|PASS|API_KEY

${BOLD}DEFAULT VALUES:${NC}
  Port:     4050
  Username: myst
  Password: mystberry

${BOLD}NOTES:${NC}
  - Nodes can use IP addresses or .local hostnames (via avahi-daemon)
  - API key is optional but required for MMN onboarding
  - Verbose mode shows identity, location, NAT type, and services
  - All nodes are tested for connectivity before being added

EOF
}

#####################################################################
# Main Entry Point
#####################################################################

main() {
    # Check if running in CLI mode (arguments provided)
    if [ $# -eq 0 ]; then
        # No arguments - run interactive mode
        interactive_mode
    else
        # Arguments provided - run CLI mode
        run_cli_mode "$@"
    fi
}

# Run main function with all arguments
main "$@"
